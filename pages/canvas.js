import Head from 'next/head';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { io } from 'socket.io-client';
import styled from 'styled-components';

const Main = styled.div`
  background-color: red;
`;
const socket = io('http://localhost:8000', {
  transports: ['websocket'],
});
export default function Home() {
  const [isDrawing, setIsDrawing] = useState(false);
  const canvasRef = useRef(null);
  const contextRef = useRef(null);
  const imageUrl = useRef(null);
  const [room, setRoom] = useState('');
  const [imageData, setImageData] = useState('');
  const [canvascontext, setCanvascontext] = useState('');
  // const [clearCanvas, setClearCanvas] = useState(true);
  const [stateList, setStateList] = useState();
  //  CANVAS FUNCTIONS FOR DRAWING DELETING
  function startDrawing({ nativeEvent }) {
    const { offsetX, offsetY } = nativeEvent;
    contextRef.current.beginPath();
    contextRef.current.moveTo(offsetX, offsetY);
    setIsDrawing(true);
  }
  const finishDrawing = () => {
    contextRef.current.closePath();
    setIsDrawing(false);
    const canvas = canvasRef.current;
    const imgData = canvas.toDataURL();
    socket.emit('canvas', imgData, room);
  };
  // const deleteCanvas = () => {
  //   const canvas = canvasRef.current;
  //   const context = canvas.getContext('2d');
  //   context.clearRect(0, 0, canvas.width, canvas.height);
  // };
  const draw = useCallback(
    ({ nativeEvent }) => {
      if (!isDrawing) {
        return;
      }
      const { offsetX, offsetY } = nativeEvent;
      contextRef.current.lineTo(offsetX, offsetY);
      contextRef.current.stroke();
    },
    [isDrawing],
  );
  //  canvas setup
  useEffect(() => {
    const canvas = canvasRef.current;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    canvas.style = `${window.innerWidth / 4}px`;
    canvas.style = `${window.innerHeight / 4}px`;
    const context = canvas.getContext('2d');
    setCanvascontext(context);
    context.lineCap = 'round';
    context.strokeStyle = 'red';
    context.lineWidth = 5;
    contextRef.current = context;
  }, []);
  useEffect(() => {
    socket.on('connect', () => {});
    return () => {
      socket.off('connect');
      socket.off('disconnect');
      socket.off('pong');
    };
  }, []);
  //   //  CANVAS FUNCTIONS FOR DRAWING DELETING

  //  socket io useStates
  const [name, setName] = useState('');
  const [list, setList] = useState([]);

  //  HANDLING POSTING TO SOCKET.IO
  // chat messages
  const handleChatpost = () => {
    socket.emit('chat', { post: name });
  };
  // setting Canvas for other users

  // getting message
  useEffect(() => {
    socket.on('message', (data) => {
      console.log(data);
      setList([...list, data]);
    });
  });
  socket.on('canvasState', (data) => {
    console.log('hi');
    setStateList(data);
    // setRoom(room1);
  });
  socket.on('reconnect_error', (err) => {
    console.log(`connect_error due to ${err.message}`);
  });
  useEffect(() => {
    const image = new Image();
    image.onload = function () {
      canvascontext.drawImage(image, 0, 0);
    };
    // console.log(stateList);
    image.src = stateList;
  });
  return (
    <>
      <div>
        <Head>
          <title>Create Next App</title>
          <meta name="description" content="Generated by create next app" />
          <link rel="icon" href="/favicon.ico" />
        </Head>
        <Main>chat</Main>
        <input
          onChange={(e) => {
            setName(e.target.value);
          }}
        />

        <button onClick={handleChatpost}>send</button>

        <input value={room} onInput={(e) => setRoom(e.target.value)} />
        {room}
        <button
          onClick={() => {
            socket.emit(
              'canvas',
              'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
              room,
            );
            socket.emit('join-room', room);
            console.log(room);
          }}
        >
          enter room
        </button>
        {list.map((name1) => (
          <div key={name1.post}>{name1.post} </div>
        ))}
      </div>
      <canvas
        style={{ height: '80vh', width: '8ovw' }}
        onMouseDown={(nativeEvent) => {
          startDrawing(nativeEvent);
        }}
        onMouseUp={(nativeEvent) => {
          finishDrawing(nativeEvent);
        }}
        onMouseMove={draw}
        ref={canvasRef}
      />
    </>
  );
}
